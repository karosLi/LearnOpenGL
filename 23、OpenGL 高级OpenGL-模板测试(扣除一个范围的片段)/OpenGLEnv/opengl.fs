#version 330 core
/**
 模板测试(Stencil Test) 会优先于 深度测试 (Depth Test)
 
 模板测试的目的：利用已经本次绘制的物体，产生一个区域，在下次绘制中利用这个区域做一些效果。
 
 模板测试的有两个要点：
 模板测试，用于剔除片段
 模板缓冲更新，用于更新出一个模板区域出来，为下次绘制做准备
 
 顺序
 模板测试 -> 模板缓冲更新
 
 
 模板缓冲区(Stencil Buffer)：与颜色缓冲区和深度缓冲区类似，模板缓冲区可以为屏幕上的每个像素点保存一个无符号整数值(8位，最大是256)。
 模板掩码函数，这里指定了一个像素点在模板缓冲区中的模板值哪些位是可以被修改的
 glStencilMask(0xFF); // 每一位都可以被修改，即启用模板缓冲写入
 glStencilMask(0x00); // 每一位都不可以被修改，即禁用模板缓冲写入
 
 虽然一个像素点的在模板缓冲区中的值可以是 0~256，但一般场景只需要用到 1 或者 0 的数值。

 
 模板测试的函数，这里指定是什么情况下通过模板测试
 glStencilFunc(GLenum func, GLint ref, GLuint mask)一共包含三个参数：
 func：设置模板测试函数(Stencil Test Function)。这个测试函数将会应用到已储存的模板值上和glStencilFunc函数的ref值上。
 GL_NEVER       总是不通过测试
 GL_ALWAYS      总是通过测试
 GL_LESS        缓冲区模板值小于参考值时测试通过
 GL_LEQUAL      缓冲区模板值小于等于参考值时测试通过
 GL_EQUAL       缓冲区模板值等于参考值时测试通过
 GL_GEQUAL      缓冲区模板值大于等于参考值时测试通过
 GL_GREATER     缓冲区模板值大于参考值时测试通过
 GL_NOTEQUAL    缓冲区模板值不等于参考值时测试通过
 
 ref：设置了模板测试的参考值(Reference Value)。模板缓冲的内容将会与这个值进行比较。
 mask：设置一个掩码，在模板测试之前，它将会与参考值和储存的模板值分别进行与运算。初始情况下所有位都为1。一般的通常将mask值设为0xFF，是为了不影响计算结果。
 
 比较流程：掩码值 mask 和参考值 ref 值先做与操作，再把当前模板中的值 stencil 与掩码值 mask 做与操作，然后参考 func 中的方法是否可以通过。这个比较方式使用了第三个参数 mask，例如 GL_LESS 通过，当且仅当 满足: ( stencil & mask ) ref < ( stencil & mask )。GL_GEQUAL通过，当且仅当( stencil & mask ) >= ( ref & mask )。
 
 
 模板缓冲（Stencil 值）更新的函数，用于指定测试通过或者失败时执行的动作
 glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)一共包含三个选项，我们能够设定每个选项应该采取的行为：
 sfail：模板测试失败时采取的行为。
 dpfail：模板测试通过，但深度测试失败时采取的行为。
 dppass：模板测试和深度测试都通过时采取的行为。
 
 GL_KEEP        保持当前储存的模板值，就是不更新模板缓冲区的值
 GL_ZERO        将模板值设置为0
 GL_REPLACE     将模板值设置为glStencilFunc函数设置的ref值
 GL_INCR        如果模板值小于最大值（8位，最大值是 256）则将模板值加1
 GL_INCR_WRAP   与GL_INCR一样，但如果模板值超过了最大值（8位，最大值是 256）则归零
 GL_DECR        如果模板值大于最小值（8位，最小值是 0）则将模板值减1
 GL_DECR_WRAP   与GL_DECR一样，但如果模板值小于0则将其设置为最大值（8位，最大值是 256）
 GL_INVERT      按位翻转当前的模板缓冲值
 
 

 应用步骤
 想象以下，模板缓冲首先会被清除为0，之后在模板缓冲中使用1填充了一个空心矩形。场景中的片段将会只在片段的模板值为1的时候会被渲染（其它的都被丢弃了）。
 模板缓冲操作允许我们在渲染片段时将模板缓冲设定为一个特定的值。通过在渲染时修改模板缓冲的内容，我们写入了模板缓冲。在同一个（或者接下来的）渲染迭代中，我们可以读取这些值，来决定丢弃还是保留某个片段。使用模板缓冲的时候你可以尽情发挥，但大体的步骤如下：

 启用模板缓冲的写入。
 渲染物体，更新模板缓冲的内容。
 禁用模板缓冲的写入。
 渲染（其它）物体，这次根据模板缓冲的内容和模板测试条件来丢弃特定的片段。
 所以，通过使用模板缓冲，我们可以根据场景中已绘制的其它物体的片段，来决定是否丢弃特定的片段。
 
 物体轮廓实践
 物体轮廓所能做的事情正如它名字所描述的那样。我们将会为每个（或者一个）物体在它的周围创建一个很小的有色边框。当你想要在策略游戏中选中一个单位进行操作的，想要告诉玩家选中的是哪个单位的时候，这个效果就非常有用了。为物体创建轮廓的步骤如下：

 在绘制（需要添加轮廓的）物体之前，将模板函数设置为GL_ALWAYS，每当物体的片段被渲染时，将模板缓冲更新为1。
 渲染物体。
 禁用模板写入以及深度测试。
 将每个物体缩放一点点。
 使用一个不同的片段着色器，输出一个单独的（边框）颜色。
 再次绘制物体，但只在它们片段的模板值不等于1时才绘制。
 再次启用模板写入和深度测试。
 这个过程将每个物体的片段的模板缓冲设置为1，当我们想要绘制边框的时候，我们主要绘制放大版本的物体中模板测试通过的部分，也就是物体的边框的位置。我们主要使用模板缓冲丢弃了放大版本中属于原物体片段的部分。
 
 
 物体轮廓理解：
 1、开启并设置模板测试条件为：总是通过测试，即本次绘制的所有片段都会通过测试并更新模板值；
 2、绘制物体并更新模板值；
 3、禁用模板缓冲写入；
 4、修改模板测试条件：没有模板值得片段才通过测试，意味着这次绘制会丢弃掉之前绘制的物体区域（并不影响上次的绘制，只会影响接下来的绘制）
 

 https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/02%20Stencil%20testing/
 */

out vec4 FragColor;

in vec2 TexCoords;

uniform sampler2D texture1;

void main()
{
    FragColor = texture(texture1, TexCoords);
    
//    FragColor = vec4(vec3(gl_FragCoord.z), 1.0);
}
